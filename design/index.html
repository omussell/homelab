<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Oliver Mussell" />
  <title>Bootstrapping a Secure Infrastructure</title>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Bootstrapping a Secure Infrastructure</h1>
<h2 class="author">Oliver Mussell</h2>
<h3 class="date">2016-2017</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#end-goal">End Goal</a></li>
<li><a href="#background">Background</a></li>
<li><a href="#high-level-design">High-Level Design</a></li>
<li><a href="#experimental">Experimental</a></li>
<li><a href="#detailed-design">Detailed Design</a><ul>
<li><a href="#ipv6">IPv6</a><ul>
<li><a href="#address-autoconfiguration-slaac">Address Autoconfiguration (SLAAC)</a></li>
<li><a href="#send">SEND</a></li>
<li><a href="#ipsec">IPsec</a></li>
<li><a href="#kink">KINK</a></li>
</ul></li>
<li><a href="#os">OS</a><ul>
<li><a href="#freebsd">FreeBSD</a></li>
<li><a href="#nanobsd">NanoBSD</a></li>
<li><a href="#jails">Jails</a></li>
<li><a href="#zfs">ZFS</a></li>
<li><a href="#other-operating-systemscontainersfilesystems">Other Operating Systems/Containers/Filesystems</a></li>
<li><a href="#host-install-tools">Host Install Tools</a></li>
<li><a href="#ad-hoc-change-tools">Ad-Hoc Change Tools</a></li>
</ul></li>
<li><a href="#dns">DNS</a><ul>
<li><a href="#dnssec">DNSSEC</a></li>
<li><a href="#dane">DANE</a></li>
<li><a href="#dane-for-email-security">DANE for Email Security</a></li>
</ul></li>
<li><a href="#ldap">LDAP</a><ul>
<li><a href="#ldaps">LDAPS</a></li>
<li><a href="#smime-or-pgp">S/MIME or PGP</a></li>
</ul></li>
<li><a href="#kerberos">Kerberos</a></li>
<li><a href="#ntp">NTP</a></li>
<li><a href="#nfs">NFS</a><ul>
<li><a href="#kerberizednfsv4">KerberizedNFSv4</a></li>
</ul></li>
<li><a href="#application-servers">Application Servers</a><ul>
<li><a href="#nginx">NGINX</a></li>
</ul></li>
<li><a href="#security-and-crypto">Security and Crypto</a><ul>
<li><a href="#against-dnssec-and-dane">Against DNSSEC (and DANE)</a></li>
<li><a href="#tls">TLS</a></li>
<li><a href="#ssh">SSH</a></li>
<li><a href="#hsm">HSM</a></li>
<li><a href="#passwords">Passwords</a></li>
<li><a href="#tcp-wrapper">TCP Wrapper</a></li>
<li><a href="#ids">IDS</a></li>
<li><a href="#firewalls">Firewalls</a></li>
</ul></li>
<li><a href="#authorisation-access-control-lists">Authorisation / Access Control Lists</a></li>
<li><a href="#role-based-access-control-shared-administration-sudo">Role-Based Access Control / Shared Administration (sudo)</a></li>
<li><a href="#domain-naming-service">Domain Naming Service</a></li>
<li><a href="#directory-service-ldap">Directory Service (LDAP)</a></li>
<li><a href="#time-service">Time Service</a></li>
<li><a href="#logging-auditing">Logging / Auditing</a></li>
<li><a href="#rpc-admin-service">RPC / Admin service</a></li>
</ul></li>
<li><a href="#designing-for-operations">Designing for Operations</a><ul>
<li><a href="#specific-operational-requirements">Specific Operational Requirements</a><ul>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#startup-and-shutdown">Startup and shutdown</a></li>
<li><a href="#queue-draining">Queue draining</a></li>
<li><a href="#software-upgrades">Software upgrades</a></li>
<li><a href="#backups-and-restores">Backups and restores</a></li>
<li><a href="#redundancy">Redundancy</a></li>
<li><a href="#replicated-databases">Replicated databases</a></li>
<li><a href="#hot-swaps">Hot swaps</a></li>
<li><a href="#access-controls-and-rate-limits">Access controls and rate limits</a></li>
<li><a href="#monitoring">Monitoring</a></li>
<li><a href="#auditing">Auditing</a></li>
</ul></li>
<li><a href="#unspecific-operational-requirements">Unspecific Operational Requirements</a><ul>
<li><a href="#assigning-ipv6-addresses-to-clients">Assigning IPv6 Addresses to Clients</a></li>
<li><a href="#static-or-dynamic-ipv6-addresses-dhcpv6-or-slaac">Static or Dynamic IPv6 Addresses (DHCPv6 or SLAAC)</a></li>
<li><a href="#ipv6-security">IPv6 Security</a></li>
<li><a href="#hostname-conventions">Hostname Conventions</a></li>
<li><a href="#choosing-an-operating-system">Choosing an Operating System</a></li>
<li><a href="#choosing-a-configuration-management-tool">Choosing a Configuration Management Tool</a></li>
</ul></li>
</ul></li>
<li><a href="#scaling">Scaling</a></li>
<li><a href="#user-access">User Access</a><ul>
<li><a href="#overview">Overview</a></li>
</ul></li>
</ul>
</div>
<ul>
<li>Produced in Markdown with Vim, converted to HTML by Pandoc.</li>
<li>Graphics created with DOT</li>
<li>Hosted on Github Pages</li>
</ul>
<p>!! needs cleanup !!</p>
<h1 id="summary"><a href="#TOC">Summary</a></h1>
<p>Create an infrastructure with an emphasis on security, resiliency and ease of maintenance.</p>
<h1 id="end-goal"><a href="#TOC">End Goal</a></h1>
<p>Produce a working implementation of a secure, resilient and easy to maintain infrastructure. This will be published in the form of version-controlled configuration documents, with the philosophy and background of the chosen configuration documented here. Anyone should be able to download the vendor supplied base operating system, and the configuration documents should convert that base OS into the desired state. The process by which this conversion is achieved could be as simple as a shell script, or as complicated as a configuration management tool backed by continuous deployment pipelines. In addition, the infrastructure should be flexible enough to be deployed in multiple configurations based on the decisions of the Infrastructure Architects and business owners. It should also be portable to other operating systems with only a little massage of the configuration code.</p>
<h1 id="background"><a href="#TOC">Background</a></h1>
<p>The design of the environment will be similar to <a href="https://en.wikipedia.org/wiki/Project_Athena">Project Athena</a> at MIT and the <a href="https://en.wikipedia.org/wiki/Distributed_Computing_Environment">Distributed Computing Environment</a> by the OSF. Inspiration for this project comes from the <a href="http://www.infrastructures.org">infrastructures.org</a> website, specifically their papers: <a href="http://www.infrastructures.org/papers/bootstrap/bootstrap.html">Bootstrapping an Infrastructure</a> and <a href="http://www.infrastructures.org/papers/turing/turing.html">Why Order Matters: Turing Equivalence in Automated Systems Administration</a>. Additionally, a paper by Paul Schenkeveld, <a href="https://2010.asiabsdcon.org/papers/abc2010-P4A-paper.pdf">Building servers with NanoBSD, ZFS and Jails</a> served as inspiration for the use of NanoBSD as the operating system due to its unique properties.</p>
<p>This project aims to extend the work of infrastructures.org and Paul Schenkeveld, by emphasising security and producing a working implementation that can be used by anyone.</p>
<h1 id="high-level-design"><a href="#TOC">High-Level Design</a></h1>
<ul>
<li>Control Machine - Stores operating system images and configuration files in version control. Used to create the Gold server.</li>
<li>Gold server - In the form of a created system image</li>
<li>Infrastructure servers - Provides directory, domain names, authentication/authorisation services</li>
<li>Data storage - Provide clients with access to their data/files via network file systems.</li>
<li>Clients - End use</li>
</ul>
<img src="/homelab/pic/secenv.svg"> <img src="/homelab/pic/disklayout.svg">
<p>!!</p>
<p>Directory servers comes in the form of DNS, using NSD as an authoritative name server, and Unbound for validating, caching and resolving servers. DNSSEC is implemented via OpenDNSSEC. SoftHSM is used for key storage (though a physical HSM would be necessary for prod). CA using OpenSSL. DANE used for D/TLS auth. Heimdal Kerberos backed by OpenLDAP. Kerberized Internet Negotiation of Keys (KINK) used for the security aspect of VPN over IPsec, used to connect sites to one another. SSH also uses Kerberos for password authentication in addition to public key authentication. OpenNTPd for time.</p>
<p>KerberizedNFSv4 for client file access.</p>
<p>!!</p>
<h1 id="experimental"><a href="#TOC">Experimental</a></h1>
<p>Features that aren’t production ready, but would be interesting to implement:</p>
<ul>
<li>SSH using X509v3 certificates, signed by a central CA (or validated with DANE?)</li>
<li>TLS using SIDH with the Microsoft Research OpenSSL patch (also validated with DANE?)</li>
</ul>
<h1 id="detailed-design"><a href="#TOC">Detailed Design</a></h1>
<p>Control machine config, Git, SSH, 2FA? Gold server, how are changes propagated? git repo hosted on this server, which each derivative server pulls from? system images can be sent via dd over SSH. Main servers - DNS in the form of NSD for authoritative, Unbound for resolving. OpenDNSSEC for key signing, keys stored in SoftHSM. DANE used for D/TLS auth. Kerberos for auth, with LDAP directory services. Everything should be authenticated with Kerberos, SSH, PKINIT, IPsec via KINK, inter-server communication, mail access etc. KerberizedNFSv4 for client file access.<br />Clients, create a thin client build, Irssi-OTR with OpenPGP keys stored in DNS/LDAP</p>
<h2 id="ipv6"><a href="#TOC">IPv6</a></h2>
<p>IPv6 is the latest version of the IP protocol, which offers significant advantages over IPv4.</p>
<p>IPv6 uses a 128-bit address which allows a much larger address space, 2^128. A single /64 subnet has a size of 2^64 addresses which equates to the square of the entire IPv4 address space. An address is represented as eight groups of four hexadecimal digits with the groups separated by colons, e.g. 2001:0db8:0000:0042:0000:8a2e:0370:7334. Guidance for representing IPv6 addresses in text is shown in <a href="https://tools.ietf.org/html/rfc5952">RFC5952</a>.</p>
<p>IPv6 addresses can be assigned in two ways, stateful or stateless, via Stateless Address Autoconfiguration (<a href="https://tools.ietf.org/html/rfc4862">SLAAC</a>) and/or DHCPv6. The stateless approach is used when a site is not particularly concerned with the addresses hosts use, whereas stateful DHCPv6 is used when a site requires tighter control over addresses. Both SLAAC and DHCPv6 may be used simultaneously.</p>
<h3 id="address-autoconfiguration-slaac"><a href="#TOC">Address Autoconfiguration (SLAAC)</a></h3>
<p>The autoconfiguration process includes generating a link-local address, generating global addresses via stateless address autoconfiguration, and the Duplicate Address Detection procedure to verify the uniqueness of the addresses on a link. The IPv6 stateless autoconfiguration mechanism requires no manual configuration of hosts, minimal configuration of routers, and no additional servers. The stateless mechanism allows a host to generate its own addresses using a combination of locally available information and information advertised by routers. Routers advertise prefixes that identify the subnet(s) associated with a link, while hosts generate an “interface identifier” that uniquely identifies an interface on a subnet. An address is formed by combining the two. In the absence of routers, a host can only generate link-local addresses. However, link-local addresses are sufficient for allowing communication among nodes attached to the same link.</p>
<p>IPv6 nodes on the same link use the Neighbor Discovery protocol to discover each others presence, to determine each others link-layer addresses, to find routers, and to maintain reachability information about the paths to active neighbors.</p>
<p>All interfaces of IPv6 hosts require a link-local address, which is derived from the MAC address of the interface and the prefix fe80::/10. The address space is filled with prefix bits left-justified to the most-significant bit, and filling the MAC address in EUI-64 format into the least-significant bits. Any remaining bits between the two parts are set to zero.</p>
<pre><code>- The left-most &#39;prefix length&#39; bits of the address are those of the link-local prefix
- The bits in the address to the right of the link-local prefix are set to all zeroes
- If the length of the interface identifier is Nbits, the right-most N bits of the address are replaced by the interface identifier</code></pre>
<p>Global addresses are formed by appending an interface identifier to a prefix of appropriate length. Prefixes are obtained from Prefix Information options contained in Router Advertisements. RA’s are sent periodically to the all-nodes multicast address. To obtain an advertisement quickly, a host send out Router Solicitations as described in <a href="https://tools.ietf.org/html/rfc4861">RFC4861</a>.</p>
<p>PICTURE OF GLOBAL ADDRESS GENERATION</p>
<p>The Neighbor Discovery Protocol (<a href="https://tools.ietf.org/html/rfc4861">NDP</a>) is used by nodes to determine the link-layer addresses for neighbors known to reside on the same attached link, to find neighboring routers to forward packets, and to keep track of neighbors that are reachable or not.</p>
<p>The [Neighbor Discovery Protocol] (NDP) is used as part of Duplicate Address Detection .</p>
<p>The IPv6 router will be allocated a subnet by the ISP and configured with the first 64 bits of the 128-bit address. <a href="https://tools.ietf.org/html/rfc4862#section-5.4">Duplicate Address Detection</a> and <a href="https://tools.ietf.org/html/rfc4861#section-7.3">Neighbor Unreachability Detection</a> serve as error handling for the address autoconfiguration.</p>
<p>Since the IPv6 addresses are generated from the prefix on the router, it is possible to renumber an entire network by changing the prefix on the router.</p>
<p>IPv6 address are mapped to hostnames in DNS using <a href="https://tools.ietf.org/html/rfc3596">AAAA resource records</a>. Reverse resolution uses the ip6.arpa domain.</p>
<h3 id="send"><a href="#TOC">SEND</a></h3>
<h3 id="ipsec"><a href="#TOC">IPsec</a></h3>
<p>Security associations via IKE or KINK</p>
<h3 id="kink"><a href="#TOC">KINK</a></h3>
<p><a href="https://tools.ietf.org/html/rfc4430">Kerberized Internet Negotiation of Keys</a> (KINK) defines a protocol to establish and maintain security associations using the Kerberos authentication system. The central key management provided by Kerberos is efficient because it limits computational cost and limits complexity versus IKE’s necessity of using public key cryptography. Initial authentication to the KDC may be performed using asymmetric keys via <a href="https://tools.ietf.org/html/rfc4556">Public Key Cryptography for Initial Authentication in Kerberos</a> (PKINIT).</p>
<h2 id="os"><a href="#TOC">OS</a></h2>
<p>The general server design would be a generic NanoBSD image occupying a flash device such as SD card serving as the operating system. Physical drives (either spinning disk or SSD) will be formatted with ZFS, on top of which the base for the jails will reside. Data used by the applications such as databases are stored on discrete storage appliances.</p>
<h3 id="freebsd"><a href="#TOC">FreeBSD</a></h3>
<p><a href="https://www.freebsd.org">FreeBSD</a> is an advanced computer operating system used to power modern servers. Its advanced networking, security, and storage features have made FreeBSD the platform of choice for embedded networking and storage devices, and powers many of the <a href="https://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/nutshell.html#introduction-nutshell-users">busiest web sites</a>.</p>
<p>FreeBSD was chosen as the operating system of choice due to the benefits of NanoBSD, Jails and ZFS. However, the tools and configurations are platform agnostic, and can be ported to other Unix-like operating systems.</p>
<h3 id="nanobsd"><a href="#TOC">NanoBSD</a></h3>
<p><a href="https://www.freebsd.org/cgi/man.cgi?query=nanobsd">NanoBSD</a> is built via shell script and produces a minimal implementation of FreeBSD which fits on small flash media. The image is customised with a configuration file, which specifies variables and functions to build the image as required. There are three stages to the image build: buildkernel, buildworld and the customise commands. The buildkernel stage is only required to be run once, further configuration changes can skip the buildkernel stage. However, some configuration changes do still require the kernel to be built. Compiling the kernel takes a long time (~30 minutes) and should be done sparingly.</p>
<p>Once the kernel and world have been built, you can customise the state of the environment using the customise commands. These are functions specified at the end of the configuration file. By skipping the buildkernel and buildworld stages, you reduce the image build time to ~20 seconds.</p>
<p>The image is only required to be built once, updated images are deployed via dd to the inactive slice. The system is then rebooted, and boots into the newly updated slice. If there are problems, change the slice back to the original, and reboot. Building the image offline also gives the advantage of being able to test the image easily prior to widespread deployment. You can dd the image to a zfs volume, then use bhyve to run the image as a virtual machine. You can then perform testing to ensure it is correct, before rolling out the image to production.</p>
<p>The flash storage is divided into three parts: the two image partitions or slices (1 and 2) containing the read-only root filesystem where only one is active, and the configuration file partition or /cfg. The /etc and /var directories are md (malloc backed) disks, which means they are located in RAM. On boot, the active slice contains the root filesystem mounted as read-only, which is beneficial since it is stored on flash media which has a limited number of writes. Configuration changes to files in /etc or /var are temporary, since they are located in RAM, and are loaded from the /cfg partition on boot. This means you can change configuration files, and if things go wrong, you can just reboot to clear the RAM. Otherwise if the new configuration is correct, you can mount /cfg, copy the changed files from /etc or /var to /cfg, then unmount again. Also, since the root filesystem is read-only, it is able to survive after an unplanned reboot. There is also no reason to run fsck after a non-graceful shutdown.</p>
<p>Since the configuration files are stored separately to the root filesystem, when switching the active slice, the configuration files are not changed. So updates and upgrades should not have an effect on the running configuration. It is also good operational practice to make sure that any configuration changes are saved to /cfg after testing, so that in the event the server reboots the configuration is still saved. This also gives administrators the flexibility to compile a custom kernel/image in order to include files/packages/kernel modules as part of the image. Doing so could result in faster boot times due to the kernel not having to query the hardware, and a reduced attack surface since unneeded components are removed. This comes at the cost of higher complexity and more difficult maintenance.</p>
<h3 id="jails"><a href="#TOC">Jails</a></h3>
<ul>
<li>A process and all descendants are restricted to a chrooted directory tree</li>
<li>Does not rely on virtualisation, so performance penalty is mitigated</li>
<li>Easy to update or upgrade individual jails</li>
</ul>
<h3 id="zfs"><a href="#TOC">ZFS</a></h3>
<ul>
<li>Data integrity using checksums</li>
<li>Pooled storage, where all disks added to the pool are available to all filesystems</li>
<li>High performance with multiple caching mechanisms</li>
<li>Snapshots</li>
</ul>
<h3 id="other-operating-systemscontainersfilesystems"><a href="#TOC">Other Operating Systems/Containers/Filesystems</a></h3>
<p>While a combination of FreeBSD, Jails and ZFS have been recommended, you are free to use other operating systems like Windows or Linux, other container formats such as LXC or Zones, and other filesystems like BTRFS or EXT. The general concepts are interchangeable.</p>
<h3 id="host-install-tools"><a href="#TOC">Host Install Tools</a></h3>
<h3 id="ad-hoc-change-tools"><a href="#TOC">Ad-Hoc Change Tools</a></h3>
<p>rsync. zfs send/receive.</p>
<h2 id="dns"><a href="#TOC">DNS</a></h2>
<p>DNS is required to provide hostname to IP mapping.</p>
<h3 id="dnssec"><a href="#TOC">DNSSEC</a></h3>
<p><a href="https://tools.ietf.org/html/rfc2535">DNSSEC</a> creates a secure domain name system by adding cryptographic signatures to existing DNS records. These digital signatures are stored in DNS name servers alongside other record types like AAAA, MX etc. By checking the associated signature, you can verify that a DNS record comes from its authoritative name server and hasn’t been altered. A basic guide of <a href="https://www.cloudflare.com/dns/dnssec/how-dnssec-works/">how DNSSEC works</a> is found <a href="https://blog.cloudflare.com/dnssec-an-introduction/">on the CloudFlare blog</a>.</p>
<p>When a DNS resolver is looking for www.example.com, the .com name servers help the resolver verify the records returned for example, and example helps verify the records returned for www. The root DNS name servers help verify .com, and information pusblished by the root is vetted at the <a href="https://www.cloudflare.com/dns/dnssec/root-signing-ceremony/">Root Signing Ceremony</a></p>
<h3 id="dane"><a href="#TOC">DANE</a></h3>
<p>DNS-Based Authentication of Named Entities or <a href="https://tools.ietf.org/html/rfc6698">DANE</a> allows certificates, used by TLS, to be bound to DNS names using DNSSEC. DANE allows you to authenticate the association of the server’s certificate with the domain name without trusting an external certificate authority. Given that the DNS administrator is authoritative for the zone, it makes sense to allow the administrator to also be authoritative for the binding between the domain name and a certificate. This is done with DNS, and the security of the information is verified with DNSSEC.</p>
<p>DANE is implemented by placing TLSA records in the DNS.</p>
<p>TLS via DANE can be used to secure websites over HTTPS, email via the <a href="https://tools.ietf.org/html/rfc7929">OpenPGP</a> and <a href="https://tools.ietf.org/html/draft-ietf-dane-smime-14">S/MIME</a> extensions, instant messaging (XMPP, IRC) and other applications via SRV records.</p>
<h3 id="dane-for-email-security"><a href="#TOC">DANE for Email Security</a></h3>
<p>Since SMTP was designed to be transmitted in plaintext, encryption in the form of <a href="https://tools.ietf.org/html/rfc3207">STARTTLS</a> or <a href="https://en.wikipedia.org/wiki/Opportunistic_TLS">Opportunistic TLS</a> was developed to secure email communication. However, <a href="https://blog.filipo.io/the-sad-state-of-smtp-encryption/">it is known</a> to be <a href="https://en.wikipedia.org/wiki/Opportunistic_TLS#Weaknesses_and_mitigations">vulnerable to downgrade attacks</a>, since the initial handshake occurs in plain text. An attacker could perform a man-in-the-middle attack by preventing the handshake from taking place and thus make it appear that TLS is unavailable, so clients revert to plain text.</p>
<p>The Electronic Frontier Foundation (<a href="https://www.eff.org">EFF</a>) has created a project called <a href="https://github.com/EFForg/starttls-everywhere">STARTTLS Everywhere</a> in an effort to enforce TLS between popular email domains, with the help of <a href="https://letsencrypt.org">Let’s Encrypt</a> to serve certificates.</p>
<p>However, this is only to serve as an <a href="https://github.com/EFForg/starttls-everywhere#alternatives">intermediate solution</a> until <a href="https://tools.ietf.org/html/draft-ietf-dane-smtp-with-dane-10">DNSSEC and DANE</a> see widespread adoption.</p>
<p>Our implementation includes DNSSEC and DANE, and so email protection will be available. However, since the infrastructure is not designed to be publicly accessible, some unique challenges surrounding maintenance of the DNS and CA root domains require solutions and also how to securely send between organisations needs to be determined.</p>
<p>While DANE can be used to validate the connection between mail exchangers, the emails themselves are still unencrypted. S/MIME and OpenPGP allow emails to be encrypted. There are also standards in place to store DANE bind</p>
<p>A guide to setting up DNSSEC+DANE to guarantee secure email between organisations is <a href="http://nccoe.nist.gov/sites/default/files/library/sp1800/dns-secure-email-sp1800-6-draft.pdf">published by NIST</a>. It shows the experiments carried out by Microsoft Corporation, NLnet Laboratories, Secure64, Internet Systems Consortium and Fraunhofer IAO, and includes the configuration required for their respective MUA, MTA and DNS services, including:</p>
<ul>
<li><a href="https://www.mozilla.org/en-GB/thunderbird/">Thunderbird</a></li>
<li><a href="https://www.dovecot.org">Dovecot</a></li>
<li><a href="http://www.postfix.org">Postfix</a></li>
<li><a href="https://en.wikipedia.org/wiki/Microsoft_Outlook">Outlook</a></li>
<li><a href="https://en.wikipedia.org/wiki/Microsoft_Exchange_Server">Exchange</a></li>
<li><a href="https://www.nlnetlabs.nl/projects/nsd/">NSD</a></li>
<li><a href="http://unbound.net">Unbound</a></li>
<li><a href="https://www.opendnssec.org">OpenDNSSEC</a></li>
<li><p><a href="https://www.isc.org/downloads/bind/">ISC BIND</a></p>
<p>Further guides published by NIST: <a href="http://dx.doi.org/10.6028/NIST.SP.800-177">Secure Domain Name System Deployment Guide</a></p></li>
</ul>
<h2 id="ldap"><a href="#TOC">LDAP</a></h2>
<h3 id="ldaps"><a href="#TOC">LDAPS</a></h3>
<h3 id="smime-or-pgp"><a href="#TOC">S/MIME or PGP</a></h3>
<h2 id="kerberos"><a href="#TOC">Kerberos</a></h2>
<h2 id="ntp"><a href="#TOC">NTP</a></h2>
<h2 id="nfs"><a href="#TOC">NFS</a></h2>
<h3 id="kerberizednfsv4"><a href="#TOC">KerberizedNFSv4</a></h3>
<h2 id="application-servers"><a href="#TOC">Application Servers</a></h2>
<h3 id="nginx"><a href="#TOC">NGINX</a></h3>
<h2 id="security-and-crypto"><a href="#TOC">Security and Crypto</a></h2>
<p>Some of the design decisions made throughout this document may be questioned by others. For example, choosing AES-GCM over ChaCha20-Poly1305, utilising IPsec which may have been influenced by the NSA and whose design is questioned by respected cryptographers, using S/MIME rather than PGP, and using DNSSEC rather than DNSCrypt.</p>
<p>As always, you are free to choose other cipher suites or software implementations. Specific reasons will be given below:</p>
<ul>
<li>1</li>
<li>2</li>
<li>3</li>
</ul>
<h3 id="against-dnssec-and-dane"><a href="#TOC">Against DNSSEC (and DANE)</a></h3>
<ul>
<li>Cryptography worst practices, Daniel J. Bernstein <a href="http://cr.yp.to/talks/2012.03.08-1/slides.pdf">slides</a>, <a href="https://vimeo.com/18279777">video</a></li>
<li><a href="https://groups.google.com/forum/#!topic/mozilla.dev.security/xylVm_kD_WE">DNSSEC in Chrome</a> (2014)</li>
<li><p><a href="https://www.imperialviolet.org/2015/01/17/notdane.html">Why not DANE in browsers</a>, Adam Langley (2015)</p></li>
<li><a href="https://dankaminsky.com/2011/01/05/djb-ccc/">Counterpoint by Dan Kaminsky</a></li>
<li><p><a href="http://blog.easydns.org/2015/08/06/for-dnssec/">Another counterpoint</a></p></li>
</ul>
<h3 id="tls"><a href="#TOC">TLS</a></h3>
<h3 id="ssh"><a href="#TOC">SSH</a></h3>
<h3 id="hsm"><a href="#TOC">HSM</a></h3>
<h3 id="passwords"><a href="#TOC">Passwords</a></h3>
<h3 id="tcp-wrapper"><a href="#TOC">TCP Wrapper</a></h3>
<h3 id="ids"><a href="#TOC">IDS</a></h3>
<h3 id="firewalls"><a href="#TOC">Firewalls</a></h3>
<h2 id="authorisation-access-control-lists"><a href="#TOC">Authorisation / Access Control Lists</a></h2>
<p>You can control access to objects using the ACL authorisation mechanism.</p>
<h2 id="role-based-access-control-shared-administration-sudo"><a href="#TOC">Role-Based Access Control / Shared Administration (sudo)</a></h2>
<h2 id="domain-naming-service"><a href="#TOC">Domain Naming Service</a></h2>
<h2 id="directory-service-ldap"><a href="#TOC">Directory Service (LDAP)</a></h2>
<h2 id="time-service"><a href="#TOC">Time Service</a></h2>
<h2 id="logging-auditing"><a href="#TOC">Logging / Auditing</a></h2>
<h2 id="rpc-admin-service"><a href="#TOC">RPC / Admin service</a></h2>
<p>!!</p>
<h1 id="designing-for-operations"><a href="#TOC">Designing for Operations</a></h1>
<h2 id="specific-operational-requirements"><a href="#TOC">Specific Operational Requirements</a></h2>
<ul>
<li>Configuration</li>
<li>Startup and shutdown</li>
<li>Queue draining</li>
<li>Software upgrades</li>
<li>Backups and restores</li>
<li>Redundancy</li>
<li>Replicated databases</li>
<li>Hot swaps</li>
<li>Access controls and rate limits</li>
<li>Monitoring</li>
<li>Auditing</li>
</ul>
<p>!!</p>
<h3 id="configuration"><a href="#TOC">Configuration</a></h3>
<p>The configuration should be able to be backed up and restored. You should be able to view the difference between one version and the other. Archive the running configuration while the system is running. This is best done with text files, as they can be stored in existing version control systems</p>
<pre><code>- NanoBSD, conf file
- Jails, conf file
- Kerberos
- OpenDNSSEC
- SoftHSM
- NSD
- Unbound
- OpenLDAP
- OpenNTP
- OpenSSH
- Configuration Management
- NFS</code></pre>
<h3 id="startup-and-shutdown"><a href="#TOC">Startup and shutdown</a></h3>
<p>Enter drain mode; Stop the applications (optional); Stop the jails (which should have scripts to stop the apps); Shutdown. Startup, start the jails on boot, mount and filesystems in jails; run apps check before saying ready; Exit drain mode.</p>
<h3 id="queue-draining"><a href="#TOC">Queue draining</a></h3>
<p>All requests are going through the load balancer, individual nodes can be put into drain mode.</p>
<h3 id="software-upgrades"><a href="#TOC">Software upgrades</a></h3>
<p>For app upgrades, snapshot current, update app, restart jail with new updated app jail. For OS upgrades, build new offline image, update slice 2, reboot.</p>
<h3 id="backups-and-restores"><a href="#TOC">Backups and restores</a></h3>
<p>Config files / OS files / data files</p>
<p>How to backup and restore:</p>
<pre><code>- Kerberos principals, groups etc.
- LDAP data
- DNS records/zones
- HSM data</code></pre>
<p>Calculate the latency/data limits required to perform above backups/restores</p>
<h3 id="redundancy"><a href="#TOC">Redundancy</a></h3>
<p>OS, hard drive, zfs, multiple core servers with master/slave, database replication, multiple load balancers. Services are behind a load balancer</p>
<h3 id="replicated-databases"><a href="#TOC">Replicated databases</a></h3>
<h3 id="hot-swaps"><a href="#TOC">Hot swaps</a></h3>
<p>Physical components should be hot swappable. Service components should also be hot swappable.</p>
<h3 id="access-controls-and-rate-limits"><a href="#TOC">Access controls and rate limits</a></h3>
<p>If a service provides an API, that API should include an Access Control List</p>
<h3 id="monitoring"><a href="#TOC">Monitoring</a></h3>
<p>Configuration management tools typically monitor the OS / Application code is correct. Use normal network monitoring tools to monitor up/down, latency etc…</p>
<h3 id="auditing"><a href="#TOC">Auditing</a></h3>
<p>Logging to central servers</p>
<h2 id="unspecific-operational-requirements"><a href="#TOC">Unspecific Operational Requirements</a></h2>
<h3 id="assigning-ipv6-addresses-to-clients"><a href="#TOC">Assigning IPv6 Addresses to Clients</a></h3>
<h3 id="static-or-dynamic-ipv6-addresses-dhcpv6-or-slaac"><a href="#TOC">Static or Dynamic IPv6 Addresses (DHCPv6 or SLAAC)</a></h3>
<h3 id="ipv6-security"><a href="#TOC">IPv6 Security</a></h3>
<p>While SEND has been recommended to prevent spoofing attacks, it is non-trivial to deploy since it requires a trust anchor and CGA uses asymmetric key crptography which is computationally expensive and may not be suitable on low-end devices. One alternative as proposed in [RFC6105]/[RFC7113], is Router Advertisement Guard (RA-Guard). This relies on an environment where all messages between IPv6 devices go through the controlled L2 networking devices. It then filters RAs based on a set of criteria, from simply “RA disallow on a given interface” to “RA allowed from SEND authorised sources only”.</p>
<p>[RFC6105] [RFC7113]</p>
<h3 id="hostname-conventions"><a href="#TOC">Hostname Conventions</a></h3>
<h3 id="choosing-an-operating-system"><a href="#TOC">Choosing an Operating System</a></h3>
<h3 id="choosing-a-configuration-management-tool"><a href="#TOC">Choosing a Configuration Management Tool</a></h3>
<h1 id="scaling"><a href="#TOC">Scaling</a></h1>
<p>AKF Scaling Cube</p>
<ul>
<li>Replicate the entire system (horizontal duplication)</li>
<li>Split the system into individual functions, services or resources (functional or service splits)</li>
<li>Split the system into individual chunks (lookup or formulaic splits)</li>
</ul>
<p>Horizontal - Many replicas behind a load balancer. If each transaction can be completed independently on all replicas, the performance improvement is proportional to the number of replicas, for example, adding more replicas, disk spindles or network connections.</p>
<p>!!</p>
<h1 id="user-access"><a href="#TOC">User Access</a></h1>
<ul>
<li>Documents</li>
<li>Applications</li>
<li>Email</li>
<li>Instant Messaging</li>
<li><p>Working remotely</p></li>
<li>Documents - Access documents through a website? Should be bound by authentication/authorisation. Version controlled documents. Like Sharepoint, but not terrible.</li>
<li>Applications - web-access only preferred, TLS available, bound by authentication/authorisation.</li>
<li>Email - How does ProtonMail do it? Usually a lot of protections and anti-spam required, but if orgs are able to authoritativly validate each other, you are only able to receive emails from those orgs that have been validated, everything else is binned. Or if an org does spam, its quick to pinpoint and can be made untrusted.</li>
<li>Instant Messaging - IRC with OTR, e.g. irc with PGP support.</li>
<li><p>Working remotely - won’t happen in a super-secure infra, but less secure may allow it. Could be done like MIT, with public SSH servers that require Kerberos name+pass and the user certificate. Then you could get X forwarded over SSH or instead of SSH, an SSL/TLS VPN that gives access to the internal network.</p></li>
</ul>
<h2 id="overview"><a href="#TOC">Overview</a></h2>
<p>Check against Digital Ocean writing guide and rubric for correctness. Assumption, that you have the necessary computing resources to build and use these servers Network switches are set up and computers can communicate and/or connect to internet</p>
<p>In the beginning, a computer will need to be connected to the public internet in order to download the operating system files, and other software required to build the initial systems. This will act as the control machine.</p>
<p>Why IPv6? pros and cons. Router Advertisements requirements, and security for Neighbour Discovery protocol should be discussed Why CARP,</p>
<p>The main prerequisite for the infrastructure is an IPv6 capable router. The router will act as the gateway between the open internet and the internal infrastructure. It is preferable to have two identical routers, managed via CARP. The router would also be responsible for NTP from upstream NTP sources, and DHCPv6 if required. Router Advertisement messages will be sent to computers in the infrastructure in order for them to generate their IP address via SLAAC. The routers may also have firewall software configured, if specific hardware firewalls are not used.</p>
<p>Then, the DNS, Authentication, Directory, Domain Naming, Time, Admin services are configured. This allows other systems in the infrastructure to find host naming information, authentication/authorisation information, correct time, etc.</p>
<p>From there, the application servers can pull information they need from the secure infra.</p>
</body>
</html>
